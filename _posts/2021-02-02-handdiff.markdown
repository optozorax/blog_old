---
layout: post
title:  "handdiff - идея системы по визуализации изменений между файлами в системах контроля версий"
tags: идеи программирование
permalink: handdiff
description: "Алгоритм diff имеет много проблем и я предлагаю новую версию, которая решает эти проблемы."
tagline: "Алгоритм diff имеет много проблем и я предлагаю новую версию, которая решает эти проблемы."
toc: false
image: /assets/img/
---

# Введение

При использовании системы контроля версий мы постоянно смотрим на содержимое коммитов и Merge Request'ов представленных в формате удаления и добавления строк. Это может быть удобно, когда мы просто отредактировали одну функцию, но неудобно при рефакторинге, когда мы что-то обернули в if, что-то переместили в другой файл, а что-то просто скопировали. И это я не говорю ещё про случаи когда всё это происходит одновременно, и вместе с другими изменениями. И в этих случаях чтобы понять что именно произошло с высокоуровневой точки зрения, приходится вручную парсить тонну этих зелёных и красных строк.

В данном посте предлагается идея того, как можно улучшить стандартный алгоритм нахождения расстояния с помощью ручной разметки, чтобы учитывались все эти случаи. Идея предлагается для обсуждения и критики. Может в будущем она послужит фундаментом к настоящим изменениям в подобных алгоритмах.

# Проблемы

Обычный алгоритм нахождения различий между файлами работает через нахождение [расстояния Левенштейна](https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%81%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5_%D0%9B%D0%B5%D0%B2%D0%B5%D0%BD%D1%88%D1%82%D0%B5%D0%B9%D0%BD%D0%B0). Пример работы этой программы можно увидеть через стандартную утилиту diff, или через систему контроля версий git.

Далее это будет называться алгоритмом diff.

Такое представление изменений в виде удаления и вставки символов может быть удобно для внутреннего представления коммитов, но не всегда удобно для человека. Ранее уже было сказано какие случаи не учитываются, поэтому для начала рассмотрим обычные проблемы данного алгоритма. Далее будут приведены примеры, которые работают для алгоритма на сайте https://www.diffchecker.com/diff, для других алгоритмов diff результаты могут немного отличаться, но общая идея одинакова для всех.

Например, у нас есть набор функций:

```python
foo()
bar()
```

И мы хотим обернуть их в `if`:
```python
if baz():
	foo()
	bar()
```

Тогда diff между этими двумя файлами будет выглядеть следующим образом:

```diff
-foo()
-bar()
+if baz():
+	foo()
+	bar()
```

И в каком-нибудь визуализаторе diff, данный результат будет выглядеть так, как будто две строчки стёрли, и написали три новые строчки, и не будет выглядеть так, как будто одна строчка добавилась, а всем остальным просто добавилась индентация. Это выглядит ещё хуже, когда таким образом оборачивается большой кусок кода. И он весь выглядит так, как будто переписан. Поэтому на ревью на него не будут обращать внимание, а что если он реально немного переписан: там 1 важный символ поменялся?

Другая проблема возникает, если вставить объект в середину других json-объектов:

```json
[
  {
  	"a": 1,
  	"b": 2,
  	"c": 3,
  },
  {
  	"a": 1,
  	"b": 2,
  	"c": 3,
  }
]
```

Вставляем: 
```json
[
  {
  	"a": 1,
  	"b": 2,
  	"c": 3,
  },
  {
  	"a": 1,
  	"b": 3,
  	"c": 3,
  },
  {
  	"a": 1,
  	"b": 2,
  	"c": 3,
  }
]
```

Разница между этими двумя версиями визуализируется следующим образом:
```diff
 [
   {
   	"a": 1,
   	"b": 2,
   	"c": 3,
   },
   {
  	"a": 1,
+  	"b": 3,
+  	"c": 3,
+  },
+  {
+  	"a": 1,
   	"b": 2,
   	"c": 3,
   }
 ]
```

Для нас намного проще воспринимать, если бы этот diff покатывался что добавились только строчки, отвечающие за новый объект:
```diff
 [
   {
   	"a": 1,
   	"b": 2,
   	"c": 3,
   },
+  {
+ 	"a": 1,
+  	"b": 3,
+  	"c": 3,
+  },
   {
   	"a": 1,
   	"b": 2,
   	"c": 3,
   }
 ]
```

Ещё один случай, который вообще противоречит идее расстояния Левенштейна - это когда мы удалили одну функцию и вставили на её место совершенно другую. В этом случае для минимизации количества изменений алгоритм diff начнёт искать минимальное число изменений, и в инструментах, которые показывают изменения не только по строкам, но ещё и по символам, это превращается в месиво: они пытаются оставить рандомные символы внутри слова, рандомные пробелы итд.

На такое месиво неприятно смотреть, и каждый раз приходится вручную понимать что там вместо модификации существуеющей на самом деле тупо вставлена новая функция.

Например, мы модифицируем наш недавний json-объект в это:
```json
[
  {
    "a": 1,
    "b": 2,
    "c": 3,
  },
  {
    "x": [1, -2],
    "y": ["b", "c"],
  },
  {
    "a": 1,
    "b": 2,
    "c": 3,
  }
]
```

Логически нам проще сказать что мы просто вставили совершенно новый объект, никак не связанный с предыдущим, но алгоритмы говорят что мы на самом деле что-то модифицировали:

![](mesivo.png)

Хотя для нас проще было бы видеть что-то такое:

```diff
 [
   {
    "a": 1,
    "b": 2,
    "c": 3,
   },
-  {
-   "a": 1,
-   "b": 3,
-   "c": 3,
-  },
+  {
+    "x": [1, -2],
+    "y": ["b", "c"],
+  },
   {
    "a": 1,
    "b": 2,
    "c": 3,
   }
 ]
```

Но это не минимальное расстояние! И это полностью противоречит алгоритму diff!

Как же бороться с такими проблемами?

# Эвристики не работают

Одним из способов бороться с такими проблемами - это написать кучу всяких эвристик на все случаи жизни, и сделать чтобы они включались специальными флагами, а ещё добавить к ним числовые параметры, чтобы что-то подкручивать.

И это худшее решение. Потому что такие эвристики будут немного работать в стандартных случаях, но когда ты встречаешься со сложной ситуацией, всё сводится к следующему: 
* Ищешь на StackOverflow готовые наборы включённых эвристик или параметров, чтобы всё было чётко.
* Сам перебираешь флаги через документацию, подбираешь числа, пытаешься найти то самое, при котором diff будет выглядеть как надо.

Тут я просто экстраполирую свой опыт работы с GraphViz. Мне нравится этот инструмент тем, что в нём можно описывать весь граф на собственном языке, и настраивать всё через язык, без GUI, ещё мне нравится что этот код можно автоматически генерировать.

Но я ненавижу GraphViz за его алгоритмы автоматической расстановки нод в графах, в 99% случаев, когда я хочу нарисовать граф, они просто выдают полную чушь. Иногда они выдают что-то разумное, но имеют просто огромные расстояния между нодами. И мне приходится гуглить и рыться в документации как сделать всё красиво. И на StackOverflow предлагают всякие решения, типо: "Поставь эту переменную в 2.5, тут флаг включи и всё будет норм". А GraphViz даже имеет концепции warning'ов, соответственно он не ругается на меня, когда я использую флаг в неправильном месте, и когда он не имеет смысла. И чаще всего это просто не работает.

Поэтому я перестал пользоваться GraphViz для рисования графов и схем, и использую draw.io, который обладает отвратительным WYSIWYG интерфейсом, которым невозможно пользоваться, когда оперируешь хоть чуть-чуть сложной диаграммой, но зато там можно вручную двигать все ноды и переходы.

Ещё draw.io плох тем, что иногда при передвижении ноды, переходы выходящие из неё, просто не передвигаются. То есть нет той бескомпромиссной связи перехода и ноды, там всё ненадёжно.

Я уверен, что все алгоритмы, которые пытаются каким-то набором эвристик покрыть всё многообразие возможностей, которыми оперирует человек, обречены на провал. GraphViz провалился, и будут провалены все эвристики, которые хочется изобретать чтобы улучшить diff алгоритм. Что же делать?

У этого есть отличный ответ: частичная ручная разметка.

# Алгоритмы + Ручная разметка = Сила

Представьте себе инструмент для рисования графов, который обладает языком GraphViz, его возможностями визуализации, и при этом позволят вручную расставлять координаты всех нод, если алгоритм автоматической расстановки не устраивает. При этом вы вручную расставляете ноды, а переходы всё ещё выходят из этой ноды, они не остаются в её прошлом положении, как это было в draw.io; переходы всё ещё рисуются автоматически, и автоматически обходят все препятствия. То есть происходит две вещи: алгоритмы автоматизируют рутинные действия, и отдают интерфейс на редактирование тому, с чем лучше справится человек - собственно, расстановка нод.

Это был бы идеальный инструмент. Но такое случается редко, мне кажется потому что у программистов есть желание всё автоматизировать, даже когда это не к месту.

Один из вариантов как такой ручной контроль можно добавить к diff - это сказать какие строчки должны быть добавлены, а какие удалены. Но не нужно вручную писать информацию для всех строк, должно быть вполне достаточно сказать информацию для нескольких строк, а далее алгоритм может сам вычислить расстояние, минимизируя число модификаций. Например, для ранее упомянутого json объекта можно сказать:

Например, вспомним наш json-объект:
```json
[
  {
  	"a": 1,
  	"b": 2,
  	"c": 3,
  }, // Говорим что эта строчка строго не изменялась
  { // Говорим что эта строчка строго новая
  	"a": 1,
  	"b": 3,
  	"c": 3,
  },
  {
  	"a": 1,
  	"b": 2,
  	"c": 3,
  }
]
```

По идее, после этих двух кусочков информации, после пересчёта алгоритма diff, он сможет нам выдать желаемый результат. А что нам стоит сказать эту информацию? Да толком ничего, всего-лишь несколько кликов в специализированном софте.

Тут ещё стоит сказать, что неизвестно как на самом деле алгоритм пересчитает это всё, так что чтобы научиться кликать в нужные места, которые точно приведут к желаемому результату, нужна практика. Но я уверен, что такому легко научиться, особенно если обратная связь будет очень быстрой.

# Перенос текста, копирование и индентация

То что я рассказал про ручную разметку, не стоит того для обычного алгоритма diff. Это улучшит читаемость MR-а ну скажем на 5%. Но это не стоит тех затрат, которые будут потрачены на разработку алгоритмов, их внедрение и создание интерфейса к ним. Зато все эти затраты будут иметь смысл, если добавить в разметку кое-что ещё.

А именно, нужно добавить возможность указывать:
* Когда текст был перемещён из одного места в другое.
* Когда у текста в первую очередь меняется индентация - это частый случай, который выглядит слишком красно и зелёно на diff'ах, но на самом деле он незначителен, и его можно выделять слабо-серым цветом, например.
* Когда часть текста копируется из одного места в другое.

В таком случае при должной визуализации смотреть на изменения от Merge Request'а будет значительно проще.


https://en.wikipedia.org/wiki/Longest_common_subsequence_problem

https://text-compare.com

https://docs.rs/lcs/0.2.0/lcs/struct.LcsTable.html

https://gist.github.com/optozorax/fad83ba0af5d2e04670a59fefc4eab7c